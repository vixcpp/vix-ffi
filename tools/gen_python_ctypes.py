#!/usr/bin/env python3
import argparse
import json
import os
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional


def die(msg: str) -> None:
    print(f"error: {msg}", file=sys.stderr)
    sys.exit(1)


def load_json(path: Path) -> Dict[str, Any]:
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:
        die(f"failed to read json: {path}: {e}")
    return {}


def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


def w(p: Path, content: str) -> None:
    ensure_dir(p.parent)
    p.write_text(content, encoding="utf-8")


def py_escape(s: str) -> str:
    return s.replace("\\", "\\\\").replace('"', '\\"')


def render_native_py(spec: Dict[str, Any]) -> str:
    pkg = spec["python"]["package"]
    lib = spec["library"]["name"]
    prefix = spec.get("symbol_prefix", "")
    functions = spec.get("functions", [])

    # search paths
    search_paths = spec.get("library", {}).get("search_paths", [])
    # allow env override
    env_var = spec.get("library", {}).get("env_var", "VIX_LIB_PATH")

    # ctypes type mapping
    # minimal set for v1 (you can extend later)
    type_map = {
        "void": "None",
        "int": "ctypes.c_int",
        "int32": "ctypes.c_int32",
        "uint32": "ctypes.c_uint32",
        "size_t": "ctypes.c_size_t",
        "u8_ptr": "ctypes.POINTER(ctypes.c_uint8)",
        "char_ptr": "ctypes.c_char_p",
        "void_ptr": "ctypes.c_void_p",
        "vix_status_ptr": "ctypes.POINTER(vix_status)",
        "vix_str": "vix_str",
        "vix_buf": "vix_buf",
        "vix_mut_buf": "vix_mut_buf",
        "vix_str_ptr": "ctypes.POINTER(vix_str)",
        "vix_buf_ptr": "ctypes.POINTER(vix_buf)",
        "vix_mut_buf_ptr": "ctypes.POINTER(vix_mut_buf)",
        "size_t_ptr": "ctypes.POINTER(ctypes.c_size_t)",
        "int32_ptr": "ctypes.POINTER(ctypes.c_int32)",
    }

    def map_type(t: str) -> str:
        if t not in type_map:
            die(f"unknown type in manifest: {t}")
        return type_map[t]

    # Build function declarations
    fn_lines: List[str] = []
    for fn in functions:
        name = fn["name"]
        symbol = fn.get("symbol", f"{prefix}{name}")
        restype = map_type(fn.get("restype", "int"))
        argtypes = [map_type(a["type"]) for a in fn.get("args", [])]
        fn_lines.append(f'    _bind("{name}", "{symbol}", {restype}, [{", ".join(argtypes)}])')

    native = f'''# Auto-generated by vix-ffi tools/gen_python_ctypes.py
# Package: {pkg}
# Library : {lib}

from __future__ import annotations

import ctypes
import os
import sys
from pathlib import Path
from typing import List, Optional


# -----------------------------------------------------------------------------
# Vix FFI core types (must match include/vix/ffi)
# -----------------------------------------------------------------------------
class vix_str(ctypes.Structure):
    _fields_ = [
        ("ptr", ctypes.c_char_p),
        ("len", ctypes.c_size_t),
    ]


class vix_buf(ctypes.Structure):
    _fields_ = [
        ("ptr", ctypes.POINTER(ctypes.c_uint8)),
        ("len", ctypes.c_size_t),
    ]


class vix_mut_buf(ctypes.Structure):
    _fields_ = [
        ("ptr", ctypes.POINTER(ctypes.c_uint8)),
        ("cap", ctypes.c_size_t),
    ]


class vix_status(ctypes.Structure):
    _fields_ = [
        ("code", ctypes.c_int32),
        ("message", vix_str),
    ]


def _decode_vix_str(s: vix_str) -> str:
    if not s.ptr or s.len == 0:
        return ""
    # ptr is c_char_p, but may not be null-terminated; respect len
    raw = ctypes.string_at(s.ptr, s.len)
    try:
        return raw.decode("utf-8", errors="replace")
    except Exception:
        return raw.decode(errors="replace")


# -----------------------------------------------------------------------------
# Library loading
# -----------------------------------------------------------------------------
def _default_lib_filename() -> str:
    name = "{py_escape(lib)}"
    if sys.platform.startswith("win"):
        return name + ".dll"
    if sys.platform == "darwin":
        return "lib" + name + ".dylib"
    return "lib" + name + ".so"


def _candidate_paths() -> List[Path]:
    out: List[Path] = []

    # 1) Env var override (colon-separated, or semicolon on Windows)
    env = os.environ.get("{py_escape(env_var)}", "")
    if env:
        sep = ";" if sys.platform.startswith("win") else ":"
        for part in env.split(sep):
            part = part.strip()
            if part:
                out.append(Path(part))

    # 2) Manifest-provided search paths
    for p in {search_paths!r}:
        out.append(Path(p))

    # 3) Local package directory (wheel-style)
    out.append(Path(__file__).resolve().parent)

    return out


def load_library() -> ctypes.CDLL:
    fname = _default_lib_filename()
    errors: List[str] = []
    for base in _candidate_paths():
        cand = (base / fname)
        if cand.exists():
            try:
                return ctypes.CDLL(str(cand))
            except Exception as e:
                errors.append(f"failed to load: {{cand}}: {{e}}")

    # Fall back to system loader search
    try:
        return ctypes.CDLL(fname)
    except Exception as e:
        errors.append(f"failed to load by name: {{fname}}: {{e}}")

    msg = "could not load native library\\n" + "\\n".join(errors)
    raise RuntimeError(msg)


_lib: Optional[ctypes.CDLL] = None


def _get_lib() -> ctypes.CDLL:
    global _lib
    if _lib is None:
        _lib = load_library()
    return _lib


def _bind(py_name: str, c_symbol: str, restype, argtypes):
    lib = _get_lib()
    try:
        fn = getattr(lib, c_symbol)
    except AttributeError as e:
        raise RuntimeError(f"missing symbol '{{c_symbol}}' in native library") from e

    fn.restype = restype
    fn.argtypes = argtypes
    globals()[py_name] = fn


def bind_all() -> None:
{os.linesep.join(fn_lines) if fn_lines else "    pass"}


# Bind on import by default
bind_all()
'''
    return native


def render_api_py(spec: Dict[str, Any]) -> str:
    pkg = spec["python"]["package"]
    api = spec.get("python", {}).get("api", [])
    # api entries are small python wrappers, not raw ctypes signatures
    # Each entry:
    # { "name": "encode", "calls": "base64_encode", "kind": "bytes_to_str" }
    lines: List[str] = []

    lines.append(f"# Auto-generated by vix-ffi tools/gen_python_ctypes.py")
    lines.append(f"# Package: {pkg}")
    lines.append("")
    lines.append("from __future__ import annotations")
    lines.append("")
    lines.append("import ctypes")
    lines.append("from typing import Optional")
    lines.append("")
    lines.append("from . import _native")
    lines.append("")
    lines.append("")
    lines.append("def _raise_status(st: _native.vix_status) -> None:")
    lines.append("    if int(st.code) == 0:")
    lines.append("        return")
    lines.append("    msg = _native._decode_vix_str(st.message)")
    lines.append("    if not msg:")
    lines.append("        msg = f\"native error code={int(st.code)}\"")
    lines.append("    raise RuntimeError(msg)")
    lines.append("")

    for entry in api:
        name = entry["name"]
        calls = entry["calls"]
        kind = entry.get("kind", "")

        if kind == "bytes_to_str":
            # signature expected:
            # int fn(in_ptr, in_len, out_ptr, out_cap, out_len_ptr, status_ptr)
            lines.append(f"def {name}(data: bytes, *, out_cap: int = 8192) -> str:")
            lines.append("    if not isinstance(data, (bytes, bytearray, memoryview)):")
            lines.append("        raise TypeError('data must be bytes-like')")
            lines.append("    b = bytes(data)")
            lines.append("    out = (ctypes.c_uint8 * int(out_cap))()")
            lines.append("    out_len = ctypes.c_size_t(0)")
            lines.append("    st = _native.vix_status()")
            lines.append(f"    rc = _native.{calls}(")
            lines.append("        ctypes.cast(ctypes.c_char_p(b), ctypes.POINTER(ctypes.c_uint8)),")
            lines.append("        ctypes.c_size_t(len(b)),")
            lines.append("        ctypes.cast(out, ctypes.POINTER(ctypes.c_uint8)),")
            lines.append("        ctypes.c_size_t(int(out_cap)),")
            lines.append("        ctypes.byref(out_len),")
            lines.append("        ctypes.byref(st),")
            lines.append("    )")
            lines.append("    if int(rc) != 0:")
            lines.append("        _raise_status(st)")
            lines.append("    raw = bytes(out[: int(out_len.value)])")
            lines.append("    return raw.decode('utf-8', errors='strict')")
            lines.append("")

        elif kind == "str_to_bytes":
            # input is str, output bytes
            lines.append(f"def {name}(text: str, *, out_cap: int = 8192) -> bytes:")
            lines.append("    if not isinstance(text, str):")
            lines.append("        raise TypeError('text must be str')")
            lines.append("    b = text.encode('utf-8')")
            lines.append("    out = (ctypes.c_uint8 * int(out_cap))()")
            lines.append("    out_len = ctypes.c_size_t(0)")
            lines.append("    st = _native.vix_status()")
            lines.append(f"    rc = _native.{calls}(")
            lines.append("        ctypes.cast(ctypes.c_char_p(b), ctypes.POINTER(ctypes.c_uint8)),")
            lines.append("        ctypes.c_size_t(len(b)),")
            lines.append("        ctypes.cast(out, ctypes.POINTER(ctypes.c_uint8)),")
            lines.append("        ctypes.c_size_t(int(out_cap)),")
            lines.append("        ctypes.byref(out_len),")
            lines.append("        ctypes.byref(st),")
            lines.append("    )")
            lines.append("    if int(rc) != 0:")
            lines.append("        _raise_status(st)")
            lines.append("    return bytes(out[: int(out_len.value)])")
            lines.append("")

        elif kind == "version":
            # signature: vix_str fn(vix_status*)
            lines.append(f"def {name}() -> str:")
            lines.append("    st = _native.vix_status()")
            lines.append(f"    s = _native.{calls}(ctypes.byref(st))")
            lines.append("    if int(st.code) != 0:")
            lines.append("        _raise_status(st)")
            lines.append("    return _native._decode_vix_str(s)")
            lines.append("")

        else:
            die(f"unknown python api kind: {kind} for {name}")

    if not api:
        lines.append("# No high-level API functions declared in manifest.")
        lines.append("")

    return "\n".join(lines) + "\n"


def render_init_py(spec: Dict[str, Any]) -> str:
    exports = spec.get("python", {}).get("exports", [])
    if not exports:
        exports = ["_native"]

    lines = []
    lines.append("# Auto-generated by vix-ffi tools/gen_python_ctypes.py")
    lines.append("")
    for e in exports:
        lines.append(f"from .{e} import *  # noqa: F401,F403")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    ap = argparse.ArgumentParser(description="Generate Python ctypes bindings for a Vix FFI library (manifest-driven).")
    ap.add_argument("--spec", required=True, help="Path to binding spec JSON.")
    ap.add_argument("--out", required=True, help="Output directory (will create python/<package>/...).")
    args = ap.parse_args()

    spec_path = Path(args.spec).resolve()
    out_dir = Path(args.out).resolve()

    spec = load_json(spec_path)

    if "python" not in spec or "package" not in spec["python"]:
        die("spec missing python.package")
    if "library" not in spec or "name" not in spec["library"]:
        die("spec missing library.name")

    pkg = spec["python"]["package"]
    pkg_dir = out_dir / "python" / pkg

    native_py = pkg_dir / "_native.py"
    api_py = pkg_dir / "api.py"
    init_py = pkg_dir / "__init__.py"

    w(native_py, render_native_py(spec))
    w(api_py, render_api_py(spec))
    w(init_py, render_init_py(spec))

    print(f"generated: {native_py}")
    print(f"generated: {api_py}")
    print(f"generated: {init_py}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
